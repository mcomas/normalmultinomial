```{r, warning==FALSE, message=FALSE}
library(normalmultinomial)
library(ggplot2)
library(ggtern)
library(mixpack)
d <- read.csv("/Users/marc/Research/packages/normalmultinomial/data/ContZero2Marc.csv", 
              sep=';', stringsAsFactors=FALSE)
set.seed(1)
```

* The original sample is

```{r}
head(d)
```

* First we work with components `FEEDER`, `BED`, `PASSAGE`.

```{r}
ind = c(5,1,3)
head(X <- d[,3+ind])
```

### Fitting asumming a normalmultinomial distribution

* To fit the sample to a normalmultinomial distribution we use the package `normalmultinomial`.

```{r}
fit1 = normalmultinomial_fitting(unname(as.matrix(X)), niter= 20, nsim = 10000)
```

* After the fitting, we can get the expected values of probabilities $p_i$ generating each observation $x_i$.

```{r}
X.fit1 = data.frame(fit1[[3]])
names(X.fit1) = names(X)
head(X.fit1)
```

* We can express the expted probabilities as the expected counting 

```{r}
head(X.fit1 * apply(X, 1, sum))
```

* The representation of sample $X$ and the expected values $A$.

```{r, fig.width=6, fig.height=4}
ggtern() + 
  geom_point(data=X, aes(x = FEEDER, y=BED, z = PASSAGE), size=3) +
  geom_point(data=X.fit1, aes(x = FEEDER, y=BED, z = PASSAGE), col='red', size=3) + theme_bw()
```

* The sample representation on the ilr space

```{r, fig.width=6, fig.height=4}
df = ilr_coordinates(X)
df.fit1 = ilr_coordinates(fit1[[3]])
ggplot() + 
  geom_point(data=df, aes(x = coord.1, y=coord.2), size=3) +
  geom_point(data=df.fit1, aes(x = coord.1, y=coord.2), col='red', size=3) + 
  xlim(-5, 4.5) + ylim(-3, 2.5)
```

### Fitting asumming three different normalmultinomial distributions

* The sample seems to form three different clusters.

```{r}
cluster = as.factor(kmeans(X, 3)$cluster)
ggtern() + 
  geom_point(data=X, aes(x = FEEDER, y=BED, z = PASSAGE, shape=cluster), size=3) +
  theme_bw()
```

* We can fit a normalmultinomial distribution to each cluster

```{r}
fit2 = lapply(split(X, cluster), function(.X){
  normalmultinomial_fitting(unname(as.matrix(.X)), niter= 20, nsim = 10000)
})
X.fit2 = data.frame(do.call('rbind', lapply(fit2, function(.fit) .fit[[3]])))
names(X.fit2) = names(X)
X.fit2$cluster = rep(names(fit2), sapply(fit2, function(.fit) nrow(.fit[[3]])))
```

* We can representent the sample and the expected probability on the simplex

```{r, fig.width=6, fig.height=4}
ggtern() + 
  geom_point(data=X, aes(x = FEEDER, y=BED, z = PASSAGE, shape=cluster), size=3) +
  geom_point(data=X.fit2, aes(x = FEEDER, y=BED, z = PASSAGE, shape=cluster), col='red', size=3) + 
  theme_bw()
```

* Also in coordinates

```{r, fig.width=6, fig.height=4}
df = ilr_coordinates(X)
df.fit2 = ilr_coordinates(X.fit2[,1:3])
df.fit2$cluster = X.fit2$cluster

ggplot() + 
  geom_point(data=df, aes(x = coord.1, y=coord.2, shape=cluster), size=3) +
  geom_point(data=df.fit2, aes(x = coord.1, y=coord.2, shape=cluster), col='red', size=3) + 
  xlim(-5, 4.5) + ylim(-3, 2.5)
```


### Fitting ot all the sample

* We can fit a normalmultinomial distribution to all the sample

```{r}
head(Y <- d[,3+1:6])
```


```{r}
fit1 = normalmultinomial_fitting(unname(as.matrix(Y)), niter= 20, nsim = 10000)
Y.fit1 = data.frame(fit1[[3]])
names(Y.fit1) = names(Y)
```

* The components `FEEDER`, `BED` and `PASSAGE` can be ploted on the ternary diagram

```{r, fig.width=6, fig.height=4}
ggtern() + 
  geom_point(data=Y, aes(x = FEEDER, y=BED, z = PASSAGE), size=3) +
  geom_point(data=Y.fit1, aes(x = FEEDER, y=BED, z = PASSAGE), col='red', size=3) +
  theme_bw()
```

* The sample with zeros

```{r}
head(Y)
```

* The sample without zeros

```{r}
head(Y.fit1) * apply(Y, 1, sum)
```
